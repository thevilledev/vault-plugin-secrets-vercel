package plugin

import (
	"context"
	"errors"
	"time"

	"github.com/hashicorp/vault/sdk/framework"
	"github.com/hashicorp/vault/sdk/logical"
	"github.com/thevilledev/vault-plugin-secrets-vercel/internal/client"
)

const (
	pathPatternConfig       = "config"
	pathConfigAPIKey        = "api_key"
	pathConfigBaseURL       = "base_url"
	pathConfigMaxTTL        = "max_ttl"
	pathConfigDefaultTeamID = "default_team_id"
	defaultMaxTTL           = 600

	pathConfigHelpDescription = `
Configuration path used to set the API key that the plugin uses to communicate with the Vercel API.
Read operations are not supported. If you want to update the configuration, write it again.
Delete operation is supported.`
	pathConfigHelpSynopsis = `
Configure the Vercel plugin backend.`
	//nolint:gosec
	pathConfigAPIKeyDescription = `
(Required) Vercel API key used to generate new tokens.
Setting this key to "mock" enables mock service client for development purposes.`
	pathConfigBaseURLDescription = `
(Optional) Base URL for the Vercel API. Used by mock tests mostly.`
	pathConfigMaxTTLDescription = `
(Optional) Maximum TTL for all the API tokens generated by this plugin. Defaults to 600 seconds.`
	pathConfigDefaultTeamIDDescription = `
(Optional) Default Team ID used for all token creation actions.
If set, individual tokens cannot override this value per token.`
)

var (
	errBackendNotConfigured = errors.New("backend not configured")
	errMissingAPIKey        = errors.New("missing api key from configuration")
	errGetConfig            = errors.New("failed to get config from storage")
	errDecode               = errors.New("failed to decode config")
	errWriteConfig          = errors.New("failed to write config to storage")
	errDeleteConfig         = errors.New("failed to delete config from storage")
)

type backendConfig struct {
	APIKey        string        `json:"api_key"`
	BaseURL       string        `json:"base_url"`
	MaxTTL        time.Duration `json:"max_ttl"`
	DefaultTeamID string        `json:"default_team_id"`
}

func (b *backend) pathConfig() []*framework.Path {
	return []*framework.Path{
		{
			Pattern:         pathPatternConfig,
			HelpSynopsis:    pathConfigHelpSynopsis,
			HelpDescription: pathConfigHelpDescription,

			Fields: map[string]*framework.FieldSchema{
				pathConfigAPIKey: {
					Type:        framework.TypeString,
					Description: pathConfigAPIKeyDescription,
					Required:    true,
				},
				pathConfigBaseURL: {
					Type:        framework.TypeString,
					Description: pathConfigBaseURLDescription,
					Default:     client.DefaultBaseURL,
				},
				pathConfigMaxTTL: {
					Type:        framework.TypeDurationSecond,
					Description: pathConfigMaxTTLDescription,
					Default:     defaultMaxTTL,
				},
				pathConfigDefaultTeamID: {
					Type:        framework.TypeString,
					Description: pathConfigDefaultTeamIDDescription,
				},
			},

			Operations: map[logical.Operation]framework.OperationHandler{
				logical.UpdateOperation: &framework.PathOperation{
					Callback: b.pathConfigWrite,
				},
				logical.CreateOperation: &framework.PathOperation{
					Callback: b.pathConfigWrite,
				},
				logical.DeleteOperation: &framework.PathOperation{
					Callback: b.pathConfigDelete,
				},
			},
			ExistenceCheck: b.pathConfigExistence(),
		},
	}
}

func (b *backend) getConfig(ctx context.Context, storage logical.Storage) (*backendConfig, error) {
	var config backendConfig

	e, err := storage.Get(ctx, pathPatternConfig)
	if err != nil {
		return nil, errGetConfig
	}

	if e == nil || len(e.Value) == 0 {
		return nil, nil
	}

	if err = e.DecodeJSON(&config); err != nil {
		return nil, errDecode
	}

	return &config, nil
}

func (b *backend) pathConfigWrite(ctx context.Context, req *logical.Request,
	data *framework.FieldData) (*logical.Response, error) {
	config := &backendConfig{}

	if v, ok := data.GetOk(pathConfigAPIKey); ok {
		config.APIKey, _ = v.(string)
	}

	if v, ok := data.GetOk(pathConfigDefaultTeamID); ok {
		config.DefaultTeamID, _ = v.(string)
	}

	if v, ok := data.GetOk(pathConfigBaseURL); ok {
		config.BaseURL, _ = v.(string)
	}

	if vr, ok := data.GetOk(pathConfigMaxTTL); ok {
		v, _ := vr.(int)

		ttl := time.Duration(v) * time.Second

		config.MaxTTL = time.Duration(ttl.Seconds())
	}

	if config.APIKey == "" {
		return nil, errMissingAPIKey
	}

	if config.BaseURL == "" {
		config.BaseURL = client.DefaultBaseURL
	}

	if config.MaxTTL == 0 {
		config.MaxTTL = defaultMaxTTL
	}

	e, err := logical.StorageEntryJSON(pathPatternConfig, config)
	if err != nil {
		return nil, err
	}

	if err = req.Storage.Put(ctx, e); err != nil {
		b.Logger().Error("failed to write config to storage", err)

		return nil, errWriteConfig
	}

	b.Logger().Info("config initialised")

	return &logical.Response{}, nil
}

func (b *backend) pathConfigDelete(ctx context.Context, req *logical.Request,
	_ *framework.FieldData) (*logical.Response, error) {
	cfg, err := b.getConfig(ctx, req.Storage)
	if err != nil {
		return nil, err
	}

	if cfg == nil {
		return nil, errBackendNotConfigured
	}

	if err = req.Storage.Delete(ctx, pathPatternConfig); err != nil {
		b.Logger().Error("failed to delete config from storage", err)

		return nil, errDeleteConfig
	}

	return &logical.Response{}, nil
}

func (b *backend) pathConfigExistence() framework.ExistenceFunc {
	return func(ctx context.Context, req *logical.Request, data *framework.FieldData) (bool, error) {
		_, err := b.getConfig(ctx, req.Storage)

		return err != nil, err
	}
}
